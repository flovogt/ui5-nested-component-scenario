/*!
 * OpenUI5
 * (c) Copyright 2025 SAP SE or an SAP affiliate company.
 * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
 */
sap.ui.define(["sap/base/util/merge","sap/ui/core/util/reflection/JsControlTreeModifier"],(e,t)=>{"use strict";const n={};n.enhanceConfig=(r,o)=>{const a=o.propertyBag;const i=a?a.modifier:t;let s;let g;return i.getControlMetadata(r).then(e=>{s=e;o.controlMetadata=s;return i.getAggregation(r,"customData")}).then(e=>Promise.all(e.map(e=>i.getProperty(e,"key"))).then(t=>e.reduce((e,n,r)=>t[r]==="xConfig"?n:e,undefined))).then(t=>{g=t;if(g){return i.getProperty(g,"value").then(t=>e({},JSON.parse(t.replace(/\\/g,""))))}return{}}).then(async t=>{let s;if(o.controlMeta&&o.controlMeta.aggregation){await n.prepareAggregationConfig(r,o,t);s=n.createAggregationConfig(r,o,t)}else{s=n.createPropertyConfig(r,o,t)}if(o.markAsModified){s.modified=true}const c=a?a.appComponent:undefined;let p=Promise.resolve();if(g){p=i.removeAggregation(r,"customData",g).then(()=>{if(r.isA){return i.destroy(g)}return Promise.resolve()})}return p.then(()=>i.createAndAddCustomData(r,"xConfig",JSON.stringify(s),c).then(()=>e({},s)))})};async function r(e,t){const n=e.map(t);const r=await Promise.all(n);const o=r.findIndex(e=>e);return e[o]}n.getCurrentItemState=async function(e,t,n,o){const a=t?.changeType;if(!t.propertyBag||!a||a.indexOf("Item")===-1){return}const{modifier:i,appComponent:s}=t.propertyBag;const g=await i.getAggregation(e,o);const c=g||[];const p=[];if(n?.aggregations?.[o]!==undefined&&Object.keys(n.aggregations[o]).length>0){Object.entries(n.aggregations[o]).forEach(([e,t])=>{if(t.visible!==false){p.push({key:e,position:t.position})}});p.sort((e,t)=>e.position-t.position);p.map(e=>delete e.position)}else{await c.reduce(async(e,t,n)=>{const o=await e;const a=await i.getAggregation(t,"customData");const g=await r(a,async e=>await i.getProperty(e,"key")==="p13nKey");if(g){const e=await i.getProperty(g,"value");const n=await i.getProperty(t,"visible");if(n&&e){p.push({key:e})}}else{const e=s?s.getRootControl()?.getLocalId(i.getId(t)):i.getId(t);const n=await i.getProperty(t,"visible");if(n&&e){p.push({key:e})}}return o},Promise.resolve())}return p};n.getCurrentSortState=async function(e,t,n,r){const o=t?.changeType;if(!t.propertyBag||!o||o.indexOf("Sort")===-1){return}const a=[];if(n?.properties?.[r]!==undefined&&Object.keys(n.properties[r]).length>0){n.properties[r].forEach((e,t)=>{a.push({key:e.key,position:t})});a.sort((e,t)=>e.position-t.position).map(e=>delete e.position)}return await Promise.resolve(a)};n.readConfig=(n,r)=>{if(r){const o=r.propertyBag?r.propertyBag.modifier:t;return o.getAggregation(n,"customData").then(e=>Promise.all(e.map(e=>o.getProperty(e,"key"))).then(t=>e.reduce((e,n,r)=>t[r]==="xConfig"?n:e,undefined))).then(t=>{if(t){return o.getProperty(t,"value").then(t=>e({},JSON.parse(t.replace(/\\/g,""))))}return null})}const o=(e,t)=>{const n=(e,t)=>{if(e){if(e.getMetadata){const n=e.getMetadata();const r=n.getAllAggregations();if(r){return r[t]}}}return undefined};const r=n(e,t);if(r){return e[r._sGetter]()}return undefined};const a=(e,t)=>{const n=e.getMetadata().getPropertyLikeSetting(t);if(n){const t=n._sGetter;return e[t]()}return undefined};const i=o(n,"customData").find(e=>a(e,"key")=="xConfig");const s=i?e({},JSON.parse(a(i,"value").replace(/\\/g,""))):null;return s};const o=function(t,n,r){const o=r.key||r.name;const{persistenceIdentifier:a}=r.value;const i=r.controlMeta;const s=r.value;const g=r.controlMetadata||t.getMetadata();const c=i.aggregation;const p=c?c:g.getDefaultAggregation().name;const{currentState:f}=r;const d=s.index;const{operation:l}=r;const u=e([],f);const y={add:(e,t,n)=>{const r={key:e};if(n){r.persistenceIdentifier=n}u.splice(t,0,r)},remove:(e,t)=>{const n=u?.find(t=>t.key==e);const r=u?.indexOf(n);if(r>-1){u.splice(r,1)}},move:(e,t)=>{const n=u?.find(t=>t.key==e);const r=u?.indexOf(n);if(r>-1){const[e]=u.splice(r,1);u.splice(t,0,e)}}};if(f instanceof Array&&l&&y[l]instanceof Function){y[l](o,d,a)}u.forEach((e,t)=>{const r=n.aggregations[p]?.[e.key];if(r){r.position=t}else{const r=f?.findIndex(t=>t.key===e.key);if(r!==t){n.aggregations[p][e.key]={position:t}}}})};n.prepareAggregationConfig=async(e,t,r)=>{const o=t.controlMeta;const a=t.controlMetadata||e.getMetadata();const i=o.aggregation;const s=i?i:a.getDefaultAggregation().name;const g=r||{};if(!g.hasOwnProperty("aggregations")){g.aggregations={}}if(!g.aggregations.hasOwnProperty(s)){if(a.hasAggregation(s)){g.aggregations[s]={};const r=await n.getCurrentItemState(e,t,g,s);r?.forEach(e=>{g.aggregations[s][e.key]={position:e.position}})}else{throw new Error("The aggregation "+s+" does not exist for"+e)}}t.currentState=t.currentState||await n.getCurrentItemState(e,t,g,s)};n.createAggregationConfig=(e,t,n)=>{const r=t.key||t.name;const a=t.controlMeta;const i=t.property;const s=t.value;const g=t.controlMetadata||e.getMetadata();const c=a.aggregation;const p=c?c:g.getDefaultAggregation().name;const f=n||{};if(!f.hasOwnProperty("aggregations")){f.aggregations={}}if(!f.aggregations.hasOwnProperty(p)){if(g.hasAggregation(p)){f.aggregations[p]={}}else{throw new Error("The aggregation "+p+" does not exist for"+e)}}if(!f.aggregations[p].hasOwnProperty(r)){f.aggregations[p][r]={}}if(s!==null||s&&s.hasOwnProperty("value")&&s.value!==null){switch(t.operation){case"move":f.aggregations[p][r][i]=s.index;if(s.persistenceIdentifier){f.aggregations[p][r]["persistenceIdentifier"]=s.persistenceIdentifier}o(e,f,t);break;case"remove":case"add":default:if(s.hasOwnProperty("value")){f.aggregations[p][r][i]=s.value;if(s.index!==undefined){f.aggregations[p][r]["position"]=s.index}if(s.persistenceIdentifier){f.aggregations[p][r]["persistenceIdentifier"]=s.persistenceIdentifier}}else{f.aggregations[p][r][i]=s}o(e,f,t);break}}else{delete f.aggregations[p][r][i];if(Object.keys(f.aggregations[p][r]).length===0){delete f.aggregations[p][r];if(Object.keys(f.aggregations[p]).length===0){delete f.aggregations[p]}}}return f};n.createPropertyConfig=(e,t,n)=>{const r=t.value;const o=t.property;const a=n||{};if(!a.properties){a.properties={}}if(!a.properties.hasOwnProperty(o)){a.properties[o]=[]}const i=t.operation;const s=a.properties[o].find(e=>e.key===t.key);if(s&&i!=="add"){a.properties[o].splice(a.properties[o].indexOf(s),1)}if(i!=="remove"){a.properties[o].splice(t.value.index,0,r)}return a};return n});
//# sourceMappingURL=xConfigAPI.js.map